\chapter{Basic Concepts}
\label{chapter:basicConcepts}



%----------NOTATION
\section{A few words about notation}

A focal objective of this report was to collect, review, correct, and homogenize all existing information concerning the inner workings of the Monero cryptocurrency. And, at the same time supply all the necessary details to present the material in a constructive and single-threaded manner.

An important instrument to achieve this was to settle for a number of notational conventions. Among others, we have used:

\begin{itemize}
\item lower case letters to denote simple values, integers, strings, bit representations, etc.
\item upper case letters to denote curve points and complicated constructs
\end{itemize}

For items with a special meaning, we have tried to use as much as possible the same symbols throughout the document. For instance, a curve generator is always denoted by \(G\), its order is \(l\), private/public keys are denoted whenever possible by \(k/K\) respectively, etc.
\\

Beyond that, we have aimed at being {\em conceptual} in our presentation of algorithms and schemes. A reader with a computer science background may feel we have neglected questions like the bit representation of items, or, in some cases, how to carry out concrete operations. Moreover, students of mathematics may find we disregarded explanations of abstract algebra.

However, we donâ€™t see this as a loss. A simple object such as an integer or a string can always be represented by a bit string. So-called `endianness' is rarely relevant, and is mostly a matter of convention for our algorithms.\footnote{In computer memory, each byte is stored in its own address (an address is akin to a numbered slot, which a byte can be stored in). A given `word' or variable is referenced by the lowest address of its bytes. If variable $x$ has 4 bytes, stored in addresses 10-13, address 10 is used to find $x$. The way bytes of $x$ are organized in its set of addresses depends on {\em endianness}, although each individual byte is always and everywhere stored the same way within its address. Basically, which end of $x$ is stored in the reference address? It could be the {\em big end} or {\em little end}. Given $x = $ 0x12345678 (hexadecimal, 2 hexadecimal digits occupy 1 byte e.g. 8 binary digits a.k.a. bits), and an array of addresses \{10, 11, 12, 13\}, the big endian encoding of $x$ is \{12, 34, 56, 78\} and the little endian encoding is \{78, 56, 34, 12\}. \cite{endianness}}

Elliptic curve points are normally denoted by pairs \((x, y)\), and can therefore be represented with two integers. However, in the world of cryptography it is common to apply {\em point compression} techniques, which allow representing a point using only the space of one coordinate. For our conceptual approach it is often accessory whether point compression is used or not, but most of the time it is implicitly assumed.\\

We\marginnote{src/crypto/ {\tt keccak.c}} have also used cryptographic hash functions freely without specifying any concrete algorithms. In the case of Monero it will typically be a \(\mathit{Keccak}\)\footnote{\label{kekkak_note}The Keccak hashing algorithm forms the basis for the NIST standard {\em SHA-3} \cite{nist-sha3}.} variant, but if not explicitly mentioned then it is not important to the theory. 

A cryptographic hash function (henceforth simply `hash function', or `hash') takes in some message $\mathfrak{m}$ of arbitrary length and returns a hash $h$ (or `message digest') of fixed length, with each possible output equiprobable for a given input. Cryptographic hash functions are difficult to reverse, have an interesting feature known as the {\em large avalanche effect} which can cause very similar messages to produce very dissimilar hashes, and it is hard to find two messages with the same message digest.

Hash functions will be applied to integers, strings, curve points, or combinations of these objects. These occurrences should be interpreted as hashes of bit representations, or the concatenation of such representations. Depending on context, the result of a hash will be numeric, a bit string, or even a curve point. Further details in this respect will be given as needed.



%----------MODULAR ARITHMETIC
\section{Modular arithmetic}
\label{sec:modular-arithmetic}

Most modern cryptography begins with modular arithmetic, which in turn begins with the modulus operation (denoted `mod'). We only care about the positive modulus, which always returns a positive integer.

The positive modulus is similar to the `remainder' after dividing two numbers, e.g. $c$ the `remainder' of $a/b$. Let's imagine a number line. To calculate $c = a \pmod b$ we stand at point $a$ then walk toward zero with each $\text{step} = b$ until we reach an integer $\geq{0}$ and $<b$. That is $c$. For example, $4$ (modulo 3) $= 1$, $-5 \pmod 4 = 3$, and so on.

Formally, the positive modulus is here defined for $c = a \pmod b$ as $a=bx+c$, where $0\leq{c}<{b}$ and $x$ is a signed integer which gets discarded ($b$ is a positive non-zero integer).

Note that, if $a \leq n$, $-a \pmod n$ is the same as $n - a$.


\subsection{Modular addition and multiplication}
\label{subsec:modular-addition-multiplication}

In computer science it is important to avoid large numbers when doing modular arithmetic. For example, if we want to compute $(29 + 87) \mod 99$ and we aren't allowed variables with three or more digits (such as $116 = 29 + 87$), then we can't compute $116 \pmod{99} = 17$ directly.

To compute $c = (a + b) \mod n$, where $a$ and $b$ are each less than the modulus $n$, we can do this:
\begin{itemize}
	\item Compute $x = n - a$. If $x > b$ then $c = a + b$, otherwise $c = b - x$.
\end{itemize}

We can compute a modular product, e.g. $(a \times b) \mod n$, with an algorithm called `double-and-add'. Let us demonstrate by example. Say we want to compute $(11 \times 9) \mod 10$. Consider, firstly, how we might compute $11 \times 9$ efficiently. We can write $11$ as a sum of powers of 2, that is $11 = 2^3 + 2^1 + 2^0$ and then write


\begin{align*}
	11 \times 9	&= (2^3 + 2^1 + 2^0) \times 9
	\\			&= 2^3 \times 9 + 2^1 \times 9 + 2^0 \times 9.
\end{align*}

We can then compute each of these products just by doubling 9, keeping the current value in our head, and substituting as appropriate, as follows:

\begin{itemize}
	\item The number 9 itself is $2^0 \times 9$ (that is, 9 doubled 0 times). We substitute this.
	\item Doubling 9 gives 18, which is $2^1 \times 9$. We substitute this.
	\item Doubling 18 gives 36, which is $2^2 \times 9$. This doesn't appear, so we don't need to substitute it, but\dots
	\item \dots doubling 36 gives 72, which is $2^3 \times 9$. We substitute this.
\end{itemize}

Thus, $11 \times 9 = (72 + 18) + 9 = 90 + 9 = 99$. Crucially, we only needed to perform 3 doublings and 2 additions, for a total of 5 operations. This is less operations than the 8 additions we would have performed if we just computed $11 \times 9$ as $11+11+11+11+11+11+11+11+11$ without realising that we can group terms that appear more than once, e.g. by writing

$$ 11 \times 9 = \big( (11+11) + (11+11) \big) + \big( (11+11) + (11+11) \big) + 11, $$

wherein $\big( (11+11) + (11+11) \big)$ appears twice, and is itself made out of two occurrences of $(11+11)$. However, as it turns out, this grouping is equivalent to that expressed by $11 \times 9 = (2^3 + 2^1 + 2^0) \times 9$.\footnote{The effect of double-and-add becomes apparent with large numbers. For example, with $2^{15} \times 2^{30}$ straight addition would require about $2^{15}$ $+$ operations, while double-and-add only requires 15!}

We can use this technique to efficiently compute the result modulo 10 by just taking the remainder after each doubling or addition, as follows:

\begin{align*}
	(11 \times 9) \mod 10	&= \big( (2^3 + 2^1 + 2^0) \times 9 \big) \mod 10
	\\						&= \big( (2^3 \times 9) \mod 10 + (2^1 \times 9) \mod 10 + (2^0 \times 9) \mod 10 \big) \mod 10
\end{align*}

We compute each term by performing doubling modulo 10.

\begin{itemize}
	\item The number 9 itself is $(2^0 \times 9) \mod 10$, (that is, 9 doubled 0 times, modulo 10). We substitute this.
	\item Doubling 9 and reducing mod 10 gives 8, which is $(2^1 \times 9) \mod 10$. We substitute this.
	\item Doubling 8 and reducing mod 10 gives 6, which is $(2^2 \times 9) \mod 10$. This doesn't appear, so we don't substitute it, but\dots
	\item \dots doubling 6 and reducing mod 10 gives 2, which is $(2^3 \times 9) \mod 10$. We substitute this.
\end{itemize}

This gives us

\begin{align*}
	(11 \times 9) \mod 10	&= (2 + 8 + 9) \mod 10
	\\						&= \big( (2 + 8) \mod 10 + 9 \big) \mod 10
	\\						&= \big( 0 + 9 \big) \mod 10
	\\						&= 9.
\end{align*}

The total number of additions we actually need to compute falls from 6 to 4, because we only need to compute $ 8+8 $ once.\\

Double-and-add is implemented by converting the first number (the `multiplicand' $a$) to binary (in our example, 7 $\rightarrow$ [0111]), then going through the binary array and doubling and adding. 

Let's make an array $A = [0111]$ and index it 3,2,1,0.\footnote{This is known as `LSB 0' numbering, since the least significant bit has index 0. We will use `LSB 0' for the rest of this chapter. The point here is clarity, not accurate conventions.} A[0] = 1 is the first element of A and is the least significant bit. We set a result variable to be initially $r = 0$, and set a sum variable to be initially $s = 8$ (more generally, we start with $s = b$). We follow this algorithm:
\begin{enumerate}
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] == 1, then $r = r + s \pmod n$.
		\item Compute $s = s + s \pmod n$.
	\end{enumerate}
	\item Use the final $r$: $c = r$.
\end{enumerate}

In our example $7*8 \pmod 9$, this sequence appears:
\begin{enumerate}
	\item $i = 0$
	\begin{enumerate}
		\item A[0] = 1, so $r = 0 + 8 \pmod 9$ = 8
		\item $s = 8 + 8 \pmod 9$ = 7
	\end{enumerate}
	\item $i = 1$
	\begin{enumerate}
		\item A[1] = 1, so $r = 8 + 7 \pmod 9$ = 6
		\item $s = 7 + 7 \pmod 9$ = 5
	\end{enumerate}
	\item $i = 2$
	\begin{enumerate}
		\item A[2] = 1, so $r = 6 + 5 \pmod 9$ = 2
		\item $s = 5 + 5 \pmod 9$ = 1
	\end{enumerate}
	\item $i = 3$
	\begin{enumerate}
		\item A[3] = 0, so $r$ stays the same
		\item $s = 1 + 1 \pmod 9$ = 2
	\end{enumerate}
	\item $r = 2$ is the result
\end{enumerate}


\subsection{Modular exponentiation}

Clearly $8^7 \pmod 9 = 8*8*8*8*8*8*8 \pmod 9$. Just like double-and-add, we can do square-and-multiply. For $a^e \pmod{n}$:
\begin{enumerate}
	\item Define $e_{scalar} \rightarrow e_{binary}$; $A = [e_{binary}]$; $r = 1$; $m = a$
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] == 1, then $r = r * m \pmod n$.
		\item Compute $m = m * m \pmod n$.
	\end{enumerate}
	\item Use the final $r$ as result.
\end{enumerate}


\subsection{Modular multiplicative inverse}

Sometimes we need $1/a \pmod n$, or in other words $a^{-1} \pmod n$. The inverse of something times itself is by definition one (identity). Imagine $0.25 = 1/4$, and then $0.25*4 = 1$.\\

In modular arithmetic, for $c = a^{-1} \pmod{n}$, $a c \equiv 1 \pmod{n}$ for $0 \leq c < n$ and for $a$ and $n$ relatively prime.\footnote{In the equation $a \equiv b \pmod{n}$, $a$ is {\em congruent} to $b \pmod{n}$, which just means \(a \pmod{n} = b \pmod{n}\).} Relatively prime means they don't share any divisors except 1 (the fraction $a/n$ can't be reduced/simplified).

We can use square-and-multiply to compute the modular multiplicative inverse when $n$ is a prime number because of {\em Fermat's little theorem}:\footnote{\label{inverse_rule_note}The modular multiplicative inverse has a rule stating:\\
{\em If $a c \equiv b \pmod{n}$ with $a$ and $n$ relatively prime, the solution to this linear congruence is given by \(c = a^{-1} b \pmod{n}\).}\cite{wiki-modular-arithmetic}\\
It means we can do $c = a^{-1} b \pmod n \rightarrow ca \equiv b \pmod n \rightarrow a \equiv c^{-1} b \pmod n$.}\vspace{.175cm}
\begin{align*} 
    a^{n-1} &\equiv 1 \pmod{n} \\
    a*a^{n-2} &\equiv 1 \pmod{n} \\
    c \equiv a^{n-2} &\equiv a^{-1} \pmod{n}
\end{align*}

More generally (and more rapidly), the so-called `extended Euclidean algorithm' \cite{extended-euclidean} can also find modular inverses.


\subsection{Modular equations}
\label{subsec:modular-equations}

Suppose we have an equation $c = 3*4*5 \pmod 9$. Computing this is straightforward. Given some operation $\circ$ (for example, $\circ = *$) between two expressions $A$ and $B$:\vspace{.175cm}
\[(A \circ B)\pmod{n} = {[A\pmod {n}] \circ [B\pmod{n}]}\pmod{n}\]

In our example, we set $A = 3*4$, $B = 5$, and $n = 9$:\vspace{.175cm}
\begin{align*}
(3*4 * 5) \pmod{9} &= {[3*4 \pmod {9}] * [5 \pmod{9}]} \pmod{9} \\
				   &= [3]*[5] \pmod 9 \\
				 c &= 6
\end{align*}

Now we have a way to do modular subtraction.\vspace{.175cm}
\begin{align*}
A - B \pmod n &\rightarrow A + (-B) \pmod n \\
			  &\rightarrow {[A \pmod {n}] + [-B \pmod{n}]} \pmod{n}
\end{align*}\\

The same principle would apply to something like $x = (a-b*c*d)^{-1} (e*f+g^{h}) \pmod n$.\footnote{The modulus of large numbers can exploit modular equations. It turns out $254 \pmod {13} \equiv 2*10*10 + 5*10 + 4 \equiv (((2)*10 + 5)*10 + 4) \pmod {13}$. An algorithm for $a \pmod n$ when $a > n$ is:
\begin{enumerate}
	\item Define $A \rightarrow [a_{decimal}]$; $r = 0$
	\item For $i = A_{size} - 1,...,0$
	\begin{enumerate}
		\item $r = (r*10 + A[i]) \pmod n$
	\end{enumerate}
	\item Use the final $r$ as result.
\end{enumerate}}



%----------ELLIPTIC CURVE CRYPTOGRAPHY
\section{Elliptic curve cryptography}
\label{EllipticCurveCryptography}


\subsection{What are elliptic curves?}
\label{elliptic_curves_section}

A\marginnote{{\tt fe}: field element} finite field \(\mathbb{F}_q\), where \(q\) is a prime number greater than 3, is the field formed by the set \(\{0, 1, 2, ..., q-1\}\). Addition and multiplication \((+,  \cdot)\) and negation $(-)$ are calculated\( \pmod q\).

``Calculated\( \pmod q\)" means\( \pmod q\) is performed on any instance of an arithmetic operation between two field elements, or negation of a single field element. For example, given a prime field \(\mathbb{F}_p\) with $p = 29$, $17+20=8$ because $37 \pmod{29} = 8$. Also, $-13 = -13 \pmod{29} = 16$.\\

Typically, an elliptic curve with a given $(a,b)$ pair is defined as the set of all points with coordinates \((x, y)\) satisfying a {\em WeierstraÃŸ} equation \cite{Hankerson:2003:GEC:940321}:\footnote{\label{notation1}Notation: The phrase $a \in \mathbb{F}$ means $a$ is some element in the field $\mathbb{F}$.}\vspace{.175cm}
\[y^2 = x^3 + a x + b \quad \textrm{where} \quad a, b, x, y \in \mathbb{F}_q\]

The cryptocurrency Monero uses a special curve belonging to the category of so-called {\em Twisted Edwards} curves \cite{Bernstein2008}, which are commonly expressed as (for a given $(a,d)$ pair):\vspace{.175cm}
\[a x^2 + y^2 = 1 + d x^2 y^2 \quad \textrm{where} \quad a, d, x, y \in \mathbb{F}_q \]


In what follows we will prefer this second form. The advantage it offers over the previously mentioned WeierstraÃŸ form is that basic cryptographic primitives require fewer arithmetic operations, resulting in faster cryptographic algorithms (see Bernstein {\em et al.} in \cite{Bernstein2007} for details).\\

Let \(P_1 = (x_1, y_1)\) and \(P_2 = (x_2, y_2)\) be two points belonging to a Twisted Edwards elliptic curve (henceforth known simply as an EC). We define addition on points by defining $P_1 + P_2 = (x_1, y_1) + (x_2, y_2)$ as the point $P_3 = (x_3, y_3)$ where\footnote{Typically elliptic curve points are converted into projective coordinates\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge.h} prior to curve operations like point addition, in order to avoid performing field inversions for efficiency. \cite{ecc-projective}}\vspace{.175cm}
\begin{align*}
x_3 & =  \frac{x_1 y_2 + y_1 x_ 2}{1 + d x_1 x_2 y_1 y_2}  \pmod{q} \\
y_3 & =  \frac{y_1 y_2 - a x_1 x_2}{1 - d x_1 x_2 y_1 y_2} \pmod{q} 
\end{align*}

These formulas for addition also apply for point doubling; that is, when  \(P_1 = P_2\). To subtract a point, invert its coordinates over the y-axis, $(x,y) \rightarrow (-x,y)$ \cite{Bernstein2008}, and use point addition. Recall that `negative' elements $-x$ of $\mathbb{F}_q$ are really $-x \pmod{q}$.
\\

Whenever two curve points are added together $P_3$ is a point on the `original' elliptic curve, or in other words all $x_3,y_3 \in \mathbb{F}_q$ and satisfy the EC equation.

Each point $P$ in EC can generate a subgroup of order (size) $u$ out of some of the other points in EC using multiples of itself. For example, some point $P$â€™s subgroup might have order 5 and contain the points $(0, P, 2P, 3P, 4P)$, each of which is in EC. At $5P$ the so-called {\em point-at-infinity} appears, which is like the `zeroâ€™ position on an EC, and has coordinates $(0, 1)$.\footnote{It turns out elliptic curves have {\em abelian group} structure under the addition operation described, since their point-at-infinity's are identity elements. A concise definition of this notion can be found under \url{https://brilliant.org/wiki/abelian-group/}.}

Conveniently, $5P + P = P$. This means the subgroup is {\em cyclic}.\footnote{\label{cyclical_note}Cyclic subgroup means, for $P$'s subgroup with order $u$, and with any integer $n$, $n P = [n \pmod{u}] P$. We can imagine ourselves standing on a point on a globe some distance from a `zero'th position, and each step we take moves us that distance. After a while, we will wind up back where we started, although it may take many revolutions before we land exactly on the original spot again. The number of steps it takes to land on the exact same spot is the `order' of the `stepping group', and all our footprints are unique points in that group. We recommend applying this concept to other ideas discussed here.} All $P$ in EC generate a cyclic subgroup. If $P$ generates a subgroup whose order is prime, then all the included points (except for the point-at-infinity) generate that same subgroup. In our example, take multiples of point $2P$:\vspace{.175cm}
\[2P, 4P, 6P, 8P, 10P \rightarrow 2P, 4P, 1P, 3P, 0\]

Another example: a subgroup with order 6 $(0, P, 2P, 3P, 4P, 5P)$. Multiples of point $2P$:\vspace{.175cm}
\[2P, 4P, 6P, 8P, 10P, 12P \rightarrow 2P, 4P, 0, 2P, 4P, 0\]
Here $2P$ has order 3. Since 6 is not prime, not all of its member points recreate the original subgroup.

Each EC has an order $N$ equal to the total number of points in the curve (including the point-at-infinity), and the orders of all subgroups generated by points are divisors of $N$ (by {\em Lagrangeâ€™s theorem}). We can imagine a set of all EC points $\{0,P_1,...,P_{N-1}\}$. If $N$ isn't prime, some points will make subgroups with orders equal to divisors of $N$.

To find the order, $u$, of any given point $P$'s subgroup:
\begin{enumerate}
    \item Find $N$ (e.g. use {\em Schoof's algorithm}).
    \item Find all the divisors of $N$.
    \item For every divisor $n$ of $N$, compute $n P$.
    \item The smallest $n$ such that $n P = 0$ is the order $u$ of the subgroup.
\end{enumerate} 

ECs\marginnote{{\tt ge}: group element} selected for cryptography typically have $N = hl$, where $l$ is some sufficiently large (such as 160 bits) prime number and $h$ is the so-called {\em cofactor} which could be as small as 1 or 2.\footnote{EC with small cofactors allow relatively faster point addition, etc. \cite{Bernstein2008}.} One point in the subgroup of size $l$ is usually selected to be the generator $G$ as a convention. For every other point $P$ in that subgroup there exists an integer $0 < n \leq l$ satisfying $P = n G$.

Let's expand our understanding. Say there is a point $P'$ with order $N$, where $N=h l$. Any other point $P_i$ can be found with some integer $n_i$ such that $P_i=n_i P'$. If $P_1=n_1 P'$ has order $l$, any $P_2=n_2 P'$ with order $l$ must be in the same subgroup as $P_1$ because $l P_1=0 = l P_2$, and if $l(n_1 P') \equiv l(n_2 P') \equiv N P'=0$, then $n_1$ \& $n_2$ must both be multiples of $h$. Since $N= h l$, there are only $l$ multiples of $h$, implying only one subgroup of size $l$ is possible.

Put simply, the subgroup formed by multiples of $(h P')$ always contains $P_1$ and $P_2$. Furthermore, $h(n' P')=0$ when $n'$ is a multiple of $l$, and there are only $h$ such variations of $n' \pmod N$ (including the point at infinity for $n' = hl$) because when $n' = h l$ it cycles back to 0: $h l P' = 0$. So, there are only $h$ points $P$ in EC where $h P$ will equal 0.

A similar argument could be applied to any subgroup of size $u$. Any two points $P_1$ and $P_2$ with order $u$ are in the same subgroup, which is composed of multiples of $(N/u) P'$.
\\ \newline
With this new understanding it is clear we can use the following algorithm to find (non-point-at-infinity) points in the subgroup of order $l$:
\begin{enumerate}
    \item Find $N$ of the elliptic curve EC, choose subgroup order $l$, compute $h=N/l$.
    \item Choose a random point $P'$ in EC.
    \item Compute $P=h P'$.
    \item If $P=0$ return to step 2, else $P$ is in the subgroup of order $l$.
\end{enumerate}

Calculating\marginnote{{\tt sc}: scalar} the scalar product between any integer $n$ and any point $P$, $nP$, is not difficult, whereas finding $n$ such that $P_1 = n P_2$ is thought to be computationally hard. By analogy to modular arithmetic, this is often called the {\em discrete logarithm problem} (DLP). Scalar multiplication can be seen as a {\em one-way function}, which paves the way for using elliptic curves for cryptography.\footnote{No known equation or algorithm can efficiently (based on available technology) solve for $n$ in $P_1 = n P_2$, meaning it would take many many years to unravel just one scalar product.}

The scalar product $nP$ is equivalent to $(((P+P)+(P+P))â€¦)$. Though not always the most efficient approach, we can use double-and-add like in Section \ref{subsec:modular-addition-multiplication}. To get the sum $R = n P$, remember we use the $+$ point operation discussed in Section \ref{elliptic_curves_section}.

\begin{enumerate}
	\item Define $n_{scalar} \rightarrow n_{binary}$; $A = [n_{binary}]$; $R = 0$, the point-at-infinity; $S = P$
	\item Iterate through: $i = (0,...,A_{size} - 1)$
	\begin{enumerate}
		\item If A[i] == 1, then R += S.
		\item Compute S += S.
	\end{enumerate}
	\item Use the final R as result.
\end{enumerate}

Note that EC scalars for points in the subgroup of size $l$ (which we will be using henceforth) are members of the finite field $\mathbb{F}_l$. This means arithmetic between scalars is mod $l$.


\subsection{Public key cryptography with elliptic curves}
\label{ec:keys}
Public key cryptography algorithms can be devised in a way analogous to modular arithmetic.

Let \(k\) be a randomly selected number satisfying \(0 < k < l\), and call it a {\em private key}.\footnote{The private key is sometimes known as a {\em secret key}. This lets us abbreviate: pk = public key, sk = secret key.} Calculate the corresponding {\em public key} \(K\) (an EC point) with the scalar product \(k G = K\). 

Due to the {\em discrete logarithm problem} (DLP) we cannot easily deduce \(k\) from \(K\) alone. This property allows us to use the values \((k, K)\) in standard public key cryptography algorithms.


\subsection{Diffie-Hellman key exchange with elliptic curves}
\label{DH_exchange_section}

A basic {\em Diffie-Hellman} \cite{Diffie-Hellman} exchange of a shared secret between {\em Alice} and {\em Bob} could take place in the following manner:

\begin{enumerate}
	\item Alice and Bob generate their own private/public keys \((k_A, K_A) \textrm{ and } (k_B, K_B)\). Both publish or exchange their public keys, and keep the private keys for themselves.

	\item Clearly, it holds that \[S = k_A K_B = k_A k_B G = k_B k_A G = k_B K_A\]

	Alice could privately calculate \(S = k_A K_B\), and Bob \(S = k_B K_A\), allowing them to use this single value as a shared secret.

	For example, if Alice has a message $m$ to send Bob, she could hash the shared secret \(h = \mathcal{H}(S)\), compute $x = m + h$, and send $x$ to Bob. Bob computes $h' = \mathcal{H}(S)$, calculates $m = x - h'$, and learns $m$.
\end{enumerate}   

An external observer would not be able to easily calculate the shared secret due to the `Diffie-Hellman Problem' (DHP), which says finding $S$ from $K_A$ and $K_B$ is very difficult. Also, the DLP prevents them from finding $k_A$ or $k_B$.\footnote{The DHP is thought to be of at least similar difficulty to the DLP, although it has not been proven. \cite{diffie-hellman-problem}}


\subsection{Schnorr signatures and the Fiat-Shamir transform}
\label{sec:schnorr-fiat-shamir}

In 1989 Claus-Peter Schnorr published a now-famous interactive authentication protocol \cite{schnorr-signatures}, generalized by Maurer in 2009 \cite{simple-zk-proof-maurer}, that allowed someone to prove they know the private key $k$ of a given public key $K$ without revealing any information about it \cite{Signatures2015BorromeanRS}. It goes something like this:

\begin{enumerate}
	\item The prover generates a random integer \(\alpha \in_R \mathbb{Z}_l\),\footnote{\label{notation3_note}Notation: The $R$ in \(\alpha \in_R \mathbb{Z}_l\) means $\alpha$ is randomly selected from \(\{1,2,3,...,l-1\}\).\marginnote{src/crypto/ crypto.cpp {\tt random32\_ unbiased()}} In other words, $\mathbb{Z}_l$ is all integers$\pmod l$. We exclude `$l$' since the point-at-infinity is not useful here.} computes $\alpha G$, and sends $\alpha G$ to the verifier.
	\item The verifier generates a random {\em challenge} $c \in_R \mathbb{Z}_l$ and sends $c$ to the prover.
	\item The prover computes the {\em response} $r = \alpha + c*k$ and sends $r$ to the verifier.
	\item The verifier computes $R = r G$ and $R' = \alpha G + c*K$, and checks $R \stackrel{?}{=} R'$.
\end{enumerate}

The verifier can compute $R' = \alpha G + c*K$ before the prover, so providing $c$ is like saying, ``I challenge you to respond with the discrete logarithm of $R'$." A challenge the prover can only overcome by knowing $k$ (except with negligible probability).

If $\alpha$ was chosen randomly by the prover then $r$ is randomly distributed \cite{SCOZZAFAVA1993313} and $k$ is information-theoretically secure within $r$ (it can still be found by solving the DLP for $K$ or $\alpha G$).\footnote{\label{information_theoretic_note}A cryptosystem with information-theoretic security is one where even an adversary with infinite computing power could not break it, because they simply wouldn't have enough information.} However, if the prover reuses $\alpha$ to prove his knowledge of $k$, anyone who knows both challenges in $r = \alpha + c*k$ and $r' = \alpha + c'*k$ can compute $k$ (two equations, two unknowns).\footnote{If the prover is a computer, you could imagine someone `cloning'/copying the computer after it generates $\alpha$, then presenting each copy with a different challenge.}\vspace{.175cm}%In security proofs, phrases like `forking lemma' and `rewind on success' are analagous to this cloning attack. See for example \cite{Liu2004}.
\[k = \frac{r-r'}{c-c'}\]

If the prover knew $c$ from the beginning (e.g. if the verifier secretly gave it to her), she could generate a random response $r$ and compute $\alpha G = r G - c K$. When she later sends $r$ to the verifier, she `proves' knowledge of $k$ without ever having to know it. Someone observing the transcript of events between prover and verifier would be none the wiser. The scheme is not {\em publicly verifiable}. \cite{Signatures2015BorromeanRS}\\

In his role as challenger, the verifier spits out a random number after receiving $\alpha G$, making him equivalent to a {\em random function}. Random functions, such as hash functions, are known as random oracles because computing one is like requesting a random number from someone \cite{Signatures2015BorromeanRS}.\footnote{More generally, ``[i]n cryptography... an oracle is any system which can give some extra information on a system, which otherwise would not be available."\cite{cryptographic-oracle}}\\

Using a hash function, instead of the verifier, to generate challenges is known as a {\em Fiat-Shamir transform} \cite{fiat-shamir-transform}, because it makes an interactive proof non-interactive and publicly verifiable \cite{Signatures2015BorromeanRS}.\footnote{The output of a cryptographic hash function $\mathcal{H}$ is uniformly distributed across the range of possible outputs. That is to say, for some input $A$, $\mathcal{H}(A) \in^D_R \mathbb{S}_H$ where $\mathbb{S}_H$ is the set of possible outputs from $\mathcal{H}$. We use $\in^D_R$ to indicate the function is deterministically random. $\mathcal{H}(A)$ produces the same thing every time, but its output is equivalent to a random number.
}\footnote{Note that non-interactive Schnorr-like proofs (and signatures) require either use of a fixed generator $G$, or inclusion of the generator in the challenge hash. Including it that way is known as key prefixing, which we discuss a bit more later (Sections \ref{blsag_note} and \ref{sec:robust-key-aggregation}).}

\subsubsection*{Non-interactive proof}

\begin{enumerate}
	\item Generate random number $\alpha \in_R \mathbb{Z}_l$, and compute $\alpha G$.
	\item Calculate the challenge using a cryptographically secure hash function, \(c = \mathcal{H}([\alpha G])\).
	\item Define the response $r = \alpha + c*k$.
	\item Publish the proof pair $(\alpha G, r)$.
\end{enumerate}

\subsubsection*{Verification}

\begin{enumerate}
	\item Calculate the challenge: \(c' = \mathcal{H}([\alpha G])\).
	\item Compute $R = r G$ and $R' = \alpha G + c'*K$.
	\item If $R = R'$ then the prover must know $k$ (except with negligible probability).
\end{enumerate}

\subsubsection*{Why it works}

\begin{align*}
r G &= (\alpha + c*k) G \\
	&= (\alpha G) + (c*k G) \\
	&= \alpha G + c*K \\
  R &= R'
\end{align*}

An important part of any proof/signature scheme is the resources required to verify them. This includes space to store proofs, and time spent verifying. In this scheme we store one EC point and one integer, and need to know the public key - another EC point. Since hash functions are comparatively fast to compute, keep in mind that verification time is mostly a function of elliptic curve operations\marginnote{src/ringct/ rctOps.cpp}.


\subsection{Signing messages}
\label{sec:signing-messages}

Typically, a cryptographic signature is performed on a cryptographic hash of a message rather than the message itself, which facilitates signing messages of varying size. However, in this report we will loosely use the term `message', and its symbol $\mathfrak{m}$, to refer to the message properly speaking and/or its hash value, unless specified.

Signing messages is a staple of Internet security that lets a message's recipient be confident its content is as intended by the signer. One common signature scheme is called ECDSA. See \cite{ecdsa}, ANSI X9.62, and \cite{Hankerson:2003:GEC:940321}.

The signature scheme we present here is an alternative formulation of the transformed Schnorr proof from before. Thinking of signatures in this way prepares us for exploring ring signatures in the next chapter.

\subsubsection*{Signature}

Assume Alice has the private/public key pair \((k_A, K_A)\). To unequivocally sign an arbitrary message $\mathfrak{m}$, she could execute the following steps:

\begin{enumerate}
	\item Generate random number $\alpha \in_R \mathbb{Z}_l$, and compute $\alpha G$.
	\item Calculate the challenge using a cryptographically secure hash function, \(c = \mathcal{H}(\mathfrak{m},[\alpha G])\).
	\item Define the response $r$ such that $\alpha = r + c*k_A$. In other words, $r = \alpha - c*k_A$.
	\item Publish the signature $(c, r)$.
\end{enumerate}

\subsubsection*{Verification}

Any third party who knows the EC domain parameters (specifying which elliptic curve was used), the signature $(c, r)$ and the signing method, $\mathfrak{m}$ and the hash function, and $K_A$ can verify the signature:

\begin{enumerate}
	\item Calculate the challenge: \(c' = \mathcal{H}(\mathfrak{m},[r G + c*K_A])\).
	\item If $c = c'$ then the signature passes.
\end{enumerate}

In this signature scheme we store two scalars, and need one public EC key.

\subsubsection*{Why it works}

This stems from the fact that
\begin{align*}
  	 r G &= (\alpha - c*k_A) G \\
  	  	 &= \alpha G - c*K_A \\
\alpha G &= r G + c*K_A \\
\mathcal{H}_n(\mathfrak{m},[\alpha G]) &= \mathcal{H}_n(\mathfrak{m},[r G + c*K_A]) \\
       c &= c'
\end{align*}

Therefore the owner of $k_A$ (Alice) created $(c,r)$ for $\mathfrak{m}$: she signed the message. The probability someone else, a forger without $k_A$, could have made $(c,r)$ is negligible, so a verifier can be confident the message was not tampered with.



%----------CURVE ED25519
\section{Curve Ed25519}
\label{Ed25519_section}

Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, {\em Ed25519}, the {\em birational equivalent}\footnote{\label{birational_note}Without giving further details, birational equivalence can be thought of as an isomorphism expressible using rational terms.} 
of the Montgomery curve {\em Curve25519}.

Both Curve25519 and Ed25519 were released by Bernstein {\em et al.} \cite{Bernstein2008, Bernstein2012, Bernstein2007}.\footnote{Dr. Bernstein also developed an encryption scheme known as ChaCha \cite{Bernstein_chacha,chacha-irtf}, which the primary Monero implementation uses to encrypt\marginnote{src/wallet/ ringdb.cpp} certain sensitive information related to users' wallets.}

The\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge.h} curve is defined over the prime field \(\mathbb{F}_{2^{255} - 19}\) (i.e. $q = 2^{255}-19$) by means of the following equation:\vspace{.175cm}
\[-x^2 + y^2 = 1 - \frac{121665}{121666} x^2 y^2\]

This curve addresses many concerns raised by the cryptography community.\footnote{Even if a curve appears to have no cryptographic security problems, it's possible the person/organization that created it knows a secret issue that only crops up in very rare curves. Such a person may have to randomly generate many curves in order to find one with a hidden weakness and no known weaknesses. If reasonable explanations are required for curve parameters, then it becomes even more difficult to find weak curves that will be accepted by the cryptographic community. Curve Ed25519 is known as a `fully rigid' curve, which means its generation process was fully explained. \cite{elliptic-curve-rigidity}} It is well known that NIST\footnote{\label{NIST_note}National Institute of Standards and Technology, \url{https://www.nist.gov/}} 
standard algorithms have issues. For example, it has recently become clear the NIST standard random number generation algorithm PNRG (the version based on elliptic curves) is flawed and contains a potential backdoor \cite{hales2014nsa}. Seen from a broader perspective, standardization authorities like NIST lead to a cryptographic monoculture, introducing a point of centralization. A great example of this was illustrated when the NSA used its influence over NIST to weaken an international cryptographic standard \cite{NSA-NIST}.

Curve Ed25519 is not subject to any patents (see \cite{ECC-patents} for a discussion on this subject), and the team behind it has
developed\marginnote{src/crypto/ crypto\_ops\_ builder/} and adapted basic cryptographic algorithms with efficiency in mind \cite{Bernstein2007}.

Twisted Edwards curves have order expressible as \(N=2^c l\), where \(l\) is a prime number and \(c\) a positive integer. In the case of curve Ed25519, its order is a 76 digit number ($l$ is 253 bits):\footnote{This means private EC keys in Ed25519 are 253 bits.}\vspace{.175cm}
\[2^3 \cdot 7237005577332262213973186563042994240857116359379907606001950938285454250989\marginnote{src/ringct/ rctOps.h {\tt curve- Order()}}\]


\subsection{Binary representation}
\label{binary_note}
Elements of \(\mathbb{F}_{2^{255} - 19} \) are encoded as 256-bit integers, so they can be represented using 32 bytes. Since each element only requires 255 bits, the most significant bit is always zero.

Consequently, any point in Ed25519 could be expressed using 64 bytes. By applying {\em point compression} techniques, described here below, however, it is possible to reduce this amount by half, to 32 bytes.


\subsection{Point compression}
\label{point_compression_section}

The Ed25519 curve has the property that its points can be easily compressed, so that representing a point will consume only the space of one coordinate. We will not delve into the mathematics necessary to justify this, but we can give a brief insight into how it works \cite{eddsa-ed25519-irtf}. Point compression for the Ed25519 curve was first described in \cite{Bernstein2012}, while the concept was first introduced in \cite{Miller:point-compression-origin}.

This point compression scheme follows from a transformation of the Twisted Edwards curve equation (assuming $a = -1$, which is true for Monero): $x^2 = (y^2-1)/(d y^2+1)$,\footnote{Here $d = - \frac{121665}{121666}$.} which indicates there are two possible $x$ values ($+$ or $-$) for each $y$. Field elements $x$ and $y$ are calculated$\pmod{q}$, so there are no actual negative values. However, taking$\pmod{q}$ of $â€“x$ will change the value between odd and even since $q$ is odd. For example: $3 \pmod{5} = 3$, $-3 \pmod{5} = 2$. In other words, the field elements $x$ and $â€“x$ have different odd/even assignments.

If we have a curve point and know its $x$ is even, but given its $y$ value the transformed curve equation outputs an odd number, then we know negating that number will give us the right $x$. One bit can convey this information, and conveniently the $y$ coordinate has an extra bit.

Assume we want to compress a point \((x, y)\).

\begin{description}
	\item[Encoding] We\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/\\ ge\_to- bytes.c} set the most significant bit of $y$ to 0 if $x$ is even, and 1 if it is odd. The resulting value $yâ€™$ will represent the curve point.
	
	\item[Decoding] \hfill
	    \begin{enumerate}
    	    \item Retrieve\marginnote{ge\_from- bytes.c}[2.05cm] the compressed point $yâ€™$, then copy its most significant bit to the parity bit $b$ before setting it to 0. Now it is the original $y$ again.
    	    \item Let \(u = y^2-1 \pmod q\) and \(v = d y^2  + 1 \pmod q\). This means $x^2 = u/v \pmod q$.
    	    \item Compute\footnote{Since $q = 2^{255}-19 \equiv 5 \pmod{8}$, $(q-5)/8$ and $(q-1)/4$ are integers.} \(z = u v^3 (u v^7)^{(q-5)/8} \pmod q\).
            \begin{enumerate}
                \item If \(v z^2 = u \pmod q\) then \(x' = z\).
                \item If \(v z^2 = -u \pmod q\) then calculate \(x' = z*2^{(q-1)/4} \pmod q\).
            \end{enumerate}
            \item Using the parity bit \(b\) from the first step, if $b \ne$ the least significant bit of $x'$ then  \(x = -x' \pmod q\), otherwise \(x = x'\).
            \item Return the decompressed point $(x,y)$.
	    \end{enumerate}
\end{description}

Implementations of Ed25519 (such as Monero) typically use the generator $G = (x,4/5)$ \cite{Bernstein2012}, where x is the `even', or $b = 0$, variant based on point decompression of \(y = 4/5 \pmod q\).


\subsection{EdDSA signature algorithm}
\label{EdDSA_section}

Bernstein and his team have developed a number of basic algorithms based on curve Ed25519.\footnote{\label{group_ops_twisted_edwards_note}See\marginnote{src/crypto/ crypto\_ops\_ builder/ ref10Comm- entedComb- ined/} \cite{Bernstein2007} for efficient group operations in Twisted Edwards EC (i.e. point addition, doubling, mixed addition, etc). See \cite{curve25519} for efficient modular arithmetic.}
For illustration purposes we will describe a highly optimized and secure alternative to the ECDSA signature scheme which, according to the authors, allows producing over 100 000 signatures per second using a commodity Intel Xeon processor \cite{Bernstein2012}. The algorithm can also be found described in Internet RFC8032 \cite{rfc8032}. Note this is a very Schnorr-like signature scheme.

Among other things, instead of generating random integers every time, it uses a hash value derived from the private key of the signer and the message itself. This circumvents security flaws related to the implementation of random number generators. Also, another goal of the algorithm is to avoid accessing secret or unpredictable memory locations to prevent so-called {\em cache timing attacks} \cite{Bernstein2012}.

We provide here an outline of the steps performed by the algorithm. A complete description and sample implementation in the Python language can be found in \cite{rfc8032}. 

\subsubsection*{Signature}

\begin{enumerate}
	\item Let \(h_k\) be a hash \(\mathcal{H}(k)\) of the signer's private key \(k\). 
	Compute \(\alpha\) as a hash \(\alpha = \mathcal{H}(h_k, \mathfrak{m})\) of the hashed private key and message. Depending on implementation, $\mathfrak{m}$ could be the actual message or its hash \cite{rfc8032}.
	
	\item Calculate \(\alpha G\) and the challenge $ch = \mathcal{H}([\alpha G], K,  \mathfrak{m})$.

	\item Calculate the response \(r = \alpha + ch \cdot k \).
	
	\item The signature is the pair \((\alpha G, r)\).
\end{enumerate}

\subsubsection*{Verification}
Verification is performed as follows

\begin{enumerate}
	\item Compute \(ch' = \mathcal{H}([\alpha G], K,  \mathfrak{m})\).
	
	\item If the equality \(2^c r G \stackrel{?}{=} 2^c \alpha G + 2^c ch'*K \) holds then the signature is valid.
\end{enumerate}

The $2^c$ term comes from Bernstein {\em et al.}â€™s general form of the EdDSA algorithm \cite{Bernstein2012}. According to that paper, though it isnâ€™t required for adequate verification, removing $2^c$ provides stronger equations.

The public key $K$ can be any EC point, but we only want to use points in the generator $G$'s subgroup. Multiplying by the cofactor $2^c$ ensures all points are in that subgroup. Alternatively, verifiers could check $l K \stackrel{?}{=} 0$, which only works if $K$ is in the subgroup. We do not know of any weaknesses caught by these precautions, though as we will see the latter method is important in Monero (Section \ref{blsag_note}).

In this signature scheme we store one EC point and one scalar, and have one public EC key.

\subsubsection*{Why it works}
\begin{align*}
2^c r G &= 2^c (\alpha + \mathcal{H}([\alpha G], K,  \mathfrak{m}) \cdot k) \cdot G \\
		&= 2^c \alpha G + 2^c \mathcal{H}([\alpha G], K,  \mathfrak{m}) \cdot K 
\end{align*}

\subsubsection*{Binary representation}

By default, an EdDSA signature would need \(64 + 32\) bytes for the EC point $\alpha G$ and scalar $r$. However, RFC8032 assumes point \(\alpha G\) is compressed, which reduces space requirements to only \(32 + 32\) bytes. We include the public key $K$, which implies \(32 + 32 + 32\) total bytes.



\section{Binary operator XOR}
\label{sec:XOR_section}

The binary operator XOR is a useful tool that will appear in Sections \ref{sec:integrated-addresses} and \ref{sec:pedersen_monero}. It takes two arguments and returns true if one, but not both, of them is true \cite{wolfram-xor}. Here is its truth table:

\begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
        A & B & A XOR B \\
    \hline\hline
        T & T & F \\
    \hline
        T & F & T \\
    \hline
        F & T & T \\
    \hline
        F & F & F \\
    \hline
    \end{tabular}
\end{center}

In the context of computer science, XOR is equivalent to bit addition modulo 2. For example, the XOR of two bit pairs:
\begin{alignat*}{1}
    \text{XOR}(\{1,1\},\{1,0\}) &= \{1+1,1+0\} \pmod 2 \\
                                &= \{0,1\} 
\end{alignat*}

Each of these also produce $\{0,1\}$: $\text{XOR}(\{1,0\},\{1,1\})$, $\text{XOR}(\{0,0\},\{0,1\})$, and $\text{XOR}(\{0,1\},\{0,0\})$. For XOR inputs with $b$ bits, there are $2^{\text{b}} - 1$ other combinations of inputs that would make the same output. This means if $C = \text{XOR}(A,B)$ and input $A \in_R \{0,...,2^{\text{b}-1}\}$, an observer who learned $C$ would gain no information about $B$.

At the same time, anyone who knows two of the elements in $\{A,B,C\}$, where $C = \text{XOR}(A,B)$, can calculate the third element, such as $A = \text{XOR}(B,C)$. XOR indicates if two elements are different or the same, so knowing $C$ and $B$ is enough to expose $A$. A careful examination of the truth table reveals this vital feature.\footnote{One interesting application of XOR (unrelated to Monero) is swapping two bit registers without a third register. We use the symbol $\oplus$ to indicate an XOR operation. $A \oplus A = 0$, so after three XOR operations between the registers: $\{A, B\} \rightarrow{} \{[A \oplus B], B\} \rightarrow{} \{[A \oplus B], B \oplus [A \oplus B]\} = \{[A \oplus B], A \oplus 0\} = \{[A \oplus B], A\} \rightarrow{} \{[A \oplus B] \oplus A, A\} = \{B, A\}$.}